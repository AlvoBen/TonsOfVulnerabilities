































namespace Microsoft.Samples.EntityDataReader
{
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Data;
  using System.Reflection;
  using System.Data.Common;
  using System.Data.Objects.DataClasses;
  using System.Data.Metadata.Edm;
  using System.Data.Objects;
  using System.Linq.Expressions;



































  public sealed class EntityDataReader : DbDataReader, IDataReader
  {

    readonly IEnumerator enumerator;
    readonly EntityDataReaderOptions options;

    T current;
    bool closed = false;

    static List scalarAttributes;
    static List scalarAttributesPlusRelatedObjectScalarAttributes;
    static List scalarAttributesPlusRelatedObjectKeyAttributes;

    readonly List attributes;

    //Attribute inner type
    private class Attribute
    {

      public readonly Type Type;
      public readonly string FullName;
      public readonly string Name;
      public readonly bool IsRelatedAttribute;

      readonly Func ValueAccessor;









      public static Func MakePropertyAccessor(PropertyInfo pi)
      {
        ParameterExpression objParam = Expression.Parameter(typeof(TObject), "obj");
        MemberExpression typedAccessor = Expression.PropertyOrField(objParam, pi.Name);
        UnaryExpression castToObject = Expression.Convert(typedAccessor, typeof(object));
        LambdaExpression lambdaExpr = Expression.Lambda(castToObject, objParam);

        return (Func)lambdaExpr.Compile();
      }


      public static Func MakeRelatedPropertyAccessor(PropertyInfo pi, PropertyInfo pi2)
      {

        Func getRelatedObject;
        {


          ParameterExpression typedParam = Expression.Parameter(typeof(T), "t");
          MemberExpression typedAccessor = Expression.PropertyOrField(typedParam, pi.Name);
          UnaryExpression castToObject = Expression.Convert(typedAccessor, typeof(object));
          LambdaExpression lambdaExpr = Expression.Lambda(castToObject, typedParam);
          getRelatedObject = (Func)lambdaExpr.Compile();
        }


        Func getRelatedObjectProperty;
        {



          ParameterExpression objParam = Expression.Parameter(typeof(object), "o");
          UnaryExpression typedParam = Expression.Convert(objParam,pi.PropertyType);
          MemberExpression typedAccessor = Expression.PropertyOrField(typedParam, pi2.Name);
          UnaryExpression castToObject = Expression.Convert(typedAccessor, typeof(TProperty));
          LambdaExpression lambdaExpr = Expression.Lambda(castToObject, objParam);
          getRelatedObjectProperty = (Func)lambdaExpr.Compile();
        }

        Func f =               
        {
          object o = getRelatedObject(t);
          if (o == null) return Default(TPROPERTY);
          return getRelatedObjectProperty(o);
        };

        return f;
      }

      public Attribute(PropertyInfo pi)
      {
        this.FullName = pi.DeclaringType.Name + "_" + pi.Name;
        this.Name = pi.Name;
        Type = pi.PropertyType;
        IsRelatedAttribute = false;

        ValueAccessor = MakePropertyAccessor(pi);
      }

      public Attribute(string fullName, string name, Type type, Func getValue, bool isRelatedAttribute)
      {
        this.FullName = fullName;
        this.Name = name;
        this.Type = type;
        this.ValueAccessor = getValue;
        this.IsRelatedAttribute = isRelatedAttribute;
      }

      public object GetValue(T target)
      {
        return ValueAccessor(target);
      }
    }
    //

    //"Scalar Types"

    static bool IsScalarType(Type t)
    {
      return scalarTypes.Contains(t);
    }
    static readonly HashSet scalarTypes = LoadScalarTypes();
    static HashSet LoadScalarTypes()
    {
      HashSet set = new HashSet()




























;


      return set;

    }
    //

    //Constructors

    public EntityDataReader(IEnumerable col)
      : this(col,EntityDataReaderOptions.Default,null) { }

    public EntityDataReader(IEnumerable col, EntityDataReaderOptions options)
      : this(col, options, null) { }

    public EntityDataReader(IEnumerable col, EntityDataReaderOptions options, ObjectContext objectContext)
    {
      this.enumerator = col.GetEnumerator();
      this.options = options;

      if (options.RecreateForeignKeysForEntityFrameworkEntities && objectContext == null)
      {
        throw new ArgumentException("If RecreateForeignKeysForEntityFrameworkEntities=true then objectContext is required");
      }


      if (scalarAttributes == null)
      {
         scalarAttributes = DiscoverScalarAttributes(typeof(T));
      }
      if (options.FlattenRelatedObjects && scalarAttributesPlusRelatedObjectScalarAttributes == null)
      {
        var atts = DiscoverRelatedObjectScalarAttributes(typeof(T));
        scalarAttributesPlusRelatedObjectScalarAttributes = atts.Concat(scalarAttributes).ToList();
      }
      if (options.RecreateForeignKeysForEntityFrameworkEntities && scalarAttributesPlusRelatedObjectKeyAttributes == null)
      {
        var atts = DiscoverRelatedObjectKeyAttributes(typeof(T), objectContext);
        scalarAttributesPlusRelatedObjectKeyAttributes = atts.Concat(scalarAttributes).ToList();
      }

      if (options.FlattenRelatedObjects)
      {
        attributes = scalarAttributesPlusRelatedObjectScalarAttributes;
      }
      else if (objectContext != null)
      {
        attributes = scalarAttributesPlusRelatedObjectKeyAttributes;
      }
      else
      {
        attributes = scalarAttributes;
      }


    }


    static List DiscoverScalarAttributes(Type thisType)
    {



      if (IsScalarType(thisType))
      {
        return new List();
      }



      var allProperties = (LINQ.where( IsScalarType(thisType.GetProperties().PropertyType)
                           ).select( thisType.GetProperties())
).ToList();









      foreach (var completeConstructor in LINQ.where( thisType.GetConstructors().GetParameters().Count() == allProperties.Count()
                                         ).select( thisType.GetConstructors())
)
      {
        var q = (LINQ.join(p).In(allProperties).On(CxNull).equals_(CxNull).select(  CxNull)


).ToList();

        if (q.Count() == allProperties.Count()) 
        {

          allProperties = ( LINQ.orderby( q.cp.Position
                            ).select( q.p )
).ToList();
          break; 
        }


      }

      return LINQ.Select(     new Attribute(allProperties)).ToList();

    }
    static List DiscoverRelatedObjectKeyAttributes(Type thisType, ObjectContext objectContext)
    {

      SortedList attributeList = new SortedList();





      var mw = objectContext.MetadataWorkspace;
      var entityTypesByName = LINQ.ToLookup(     mw.GetItems(DataSpace.OSpace).FullName).Select(mw.GetItems(DataSpace.OSpace));


      EntityType thisEntity = entityTypesByName[thisType.FullName].First();
      var thisEntityKeys = LINQ.ToDictionary(     thisEntity.KeyMembers.Name).Select(thisEntity.KeyMembers);





      var erProps = LINQ.Where(     typeof(EntityReference)
                            .IsAssignableFrom(thisType.GetProperties().PropertyType)).ToList().Select(thisType.GetProperties()
                            );



      foreach (var pi in erProps)
      {


        string relatedEntityCLRTypeName = pi.PropertyType.GetGenericArguments().First().FullName;


        EntityType relatedEntityEFType = entityTypesByName[relatedEntityCLRTypeName].FirstOrDefault();
        if (relatedEntityEFType == null)
        {
          throw new InvalidOperationException("Cannot find EntityType for EntityReference Property " + pi.Name);
        }








        foreach (var key in relatedEntityEFType.KeyMembers)
        {
          string targetKeyAttributeName = key.Name;




          string referenceName;
          if (pi.Name.EndsWith("Reference",StringComparison.Ordinal))
          {
            referenceName = pi.Name.Substring(0, pi.Name.Length - "Reference".Length);
          }
          else  
          {
            referenceName = pi.PropertyType.Name;


            int ix = LINQ.Where(     erProps.PropertyType == pi.PropertyType).ToList().IndexOf(pi).Select(erProps);
            if (ix > 0)
            {
              referenceName = referenceName + ix.ToString(System.Globalization.CultureInfo.InvariantCulture);
            }

          }
          string fullName = referenceName + "_" + key.Name;



          Type kType = Type.GetType(key.TypeUsage.EdmType.FullName);
          PropertyInfo entityReferenceProperty = pi;

          Func valueAccessor = new 
          {
            EntityReference er = (EntityReference)entityReferenceProperty.GetValue(o, null);


            if (er.EntityKey == null)
            {
              return null;
            }
            object val = LINQ.First(     er.EntityKey.EntityKeyValues.Key == targetKeyAttributeName).Select(er.EntityKey.EntityKeyValues).Value;
            return val;
          };
          string name = key.Name;

          attributeList.Add(name, new Attribute(fullName, name, kType, valueAccessor, true));
        }


      }

      return attributeList.Values.ToList();

    }
    static List DiscoverRelatedObjectScalarAttributes(Type thisType)
    {

      List atts = new List();


      var relatedObjectProperties =
                        (LINQ.where( !IsScalarType(thisType.GetProperties().PropertyType)
                            && !typeof(System.Collections.IEnumerable).IsAssignableFrom(thisType.GetProperties().PropertyType)
                            && !typeof(EntityReference).IsAssignableFrom(thisType.GetProperties().PropertyType)
                            && !typeof(EntityKey).IsAssignableFrom(thisType.GetProperties().PropertyType)
                         ).select( thisType.GetProperties())
).ToList();

      foreach (var rop in relatedObjectProperties)
      {
       var type = rop.PropertyType;

       var scalars = LINQ.Where(     IsScalarType(type.GetProperties().PropertyType)).ToList().Select(type.GetProperties());

       foreach (var sp in scalars)
       {
         string attName = rop.Name + "_" + sp.Name;

         var valueAccessor = Attribute.MakeRelatedPropertyAccessor(rop, sp);
         string name = attName;
         Attribute att = new Attribute(rop.Name, attName,sp.PropertyType,valueAccessor,true);
         atts.Add(att);
       }

      }
      return atts;

    }



    //

    //Utility Methods
    static Type nullable_T = typeof(System.Nullable).GetGenericTypeDefinition();
    static bool IsNullable(Type t)
    {
      return (t.IsGenericType
          && t.GetGenericTypeDefinition() == nullable_T);
    }
    static Type StripNullableType(Type t)
    {
      return t.GetGenericArguments()[0];
    }
    //

    //GetSchemaTable


    const string shemaTableSchema = @"<?xml version=""1.0"" standalone=""yes""?>
<xs:schema id=""NewDataSet"" xmlns="""" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:msdata=""urn:schemas-microsoft-com:xml-msdata"">
  <xs:element name=""NewDataSet"" msdata:IsDataSet=""true"" msdata:MainDataTable=""SchemaTable"" msdata:Locale="""">
    <xs:complexType>
      <xs:choice minOccurs=""0"" maxOccurs=""unbounded"">
        <xs:element name=""SchemaTable"" msdata:Locale="""" msdata:MinimumCapacity=""1"">
          <xs:complexType>
            <xs:sequence>
              <xs:element name=""ColumnName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""ColumnOrdinal"" msdata:ReadOnly=""true"" type=""xs:int"" default=""0"" minOccurs=""0"" />
              <xs:element name=""ColumnSize"" msdata:ReadOnly=""true"" type=""xs:int"" minOccurs=""0"" />
              <xs:element name=""NumericPrecision"" msdata:ReadOnly=""true"" type=""xs:short"" minOccurs=""0"" />
              <xs:element name=""NumericScale"" msdata:ReadOnly=""true"" type=""xs:short"" minOccurs=""0"" />
              <xs:element name=""IsUnique"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""IsKey"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""BaseServerName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""BaseCatalogName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""BaseColumnName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""BaseSchemaName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""BaseTableName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""DataType"" msdata:DataType=""System.Type, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""AllowDBNull"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""ProviderType"" msdata:ReadOnly=""true"" type=""xs:int"" minOccurs=""0"" />
              <xs:element name=""IsAliased"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""IsExpression"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""IsIdentity"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""IsAutoIncrement"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""IsRowVersion"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""IsHidden"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""IsLong"" msdata:ReadOnly=""true"" type=""xs:boolean"" default=""false"" minOccurs=""0"" />
              <xs:element name=""IsReadOnly"" msdata:ReadOnly=""true"" type=""xs:boolean"" minOccurs=""0"" />
              <xs:element name=""ProviderSpecificDataType"" msdata:DataType=""System.Type, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""DataTypeName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""XmlSchemaCollectionDatabase"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""XmlSchemaCollectionOwningSchema"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""XmlSchemaCollectionName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""UdtAssemblyQualifiedName"" msdata:ReadOnly=""true"" type=""xs:string"" minOccurs=""0"" />
              <xs:element name=""NonVersionedProviderType"" msdata:ReadOnly=""true"" type=""xs:int"" minOccurs=""0"" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>";
    public override DataTable GetSchemaTable()
    {
      DataSet s = new DataSet();
      s.Locale = System.Globalization.CultureInfo.CurrentCulture;
      s.ReadXmlSchema(new System.IO.StringReader(shemaTableSchema));
      DataTable t = s.Tables[0];
      for (int i = 0; i < this.FieldCount; i++)
      {
        DataRow row = t.NewRow();
        row["ColumnName"] = this.GetName(i);
        row["ColumnOrdinal"] = i;

        Type type = this.GetFieldType(i);
        if (type.IsGenericType
          && type.GetGenericTypeDefinition() == typeof(System.Nullable).GetGenericTypeDefinition())
        {
          type = type.GetGenericArguments()[0];
        }
        row["DataType"] = this.GetFieldType(i);
        row["DataTypeName"] = this.GetDataTypeName(i);
        row["ColumnSize"] = -1;
        t.Rows.Add(row);
      }
      return t;

    }
    //

    //IDataReader Members

    public override void Close()
    {
      closed = true;
    }

    public override int Depth
    {
      get { return 1; }
    }


    public override bool IsClosed
    {
      get { return closed; }
    }

    public override bool NextResult()
    {
      return false;
    }

    int entitiesRead = 0;
    public override bool Read()
    {
       bool rv =  enumerator.MoveNext();
       if (rv)
       {
         current = enumerator.Current;
         entitiesRead += 1;
       }
       return rv;
    }

    public override int RecordsAffected
    {
      get { return -1; }
    }

    //

    //IDisposable Members

    protected override void Dispose(bool disposing)
    {
      Close();
      base.Dispose(disposing);
    }

    //

    //IDataRecord Members

    public override int FieldCount
    {
      get
      {
        return attributes.Count;
      }
    }

    TField GetValue(int i)
    {
      TField val = (TField)attributes[i].GetValue(current);
      return val;
    }
    public override bool GetBoolean(int i)
    {
      return GetValue(i);
    }

    public override byte GetByte(int i)
    {
      return GetValue(i);
    }

    public override long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length)
    {

      var buf = GetValue(i);
      int bytes = Math.Min(length, buf.Length - (int)fieldOffset);
      Buffer.BlockCopy(buf, (int)fieldOffset, buffer, bufferoffset, bytes);
      return bytes;

    }

    public override char GetChar(int i)
    {
      return GetValue(i);
    }

    public override long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length)
    {

      string s = GetValue(i);
      int chars   = Math.Min(length, s.Length-(int)fieldoffset );
      s.CopyTo((int)fieldoffset, buffer, bufferoffset, chars);

      return chars;
    }






    public override string GetDataTypeName(int i)
    {
      return attributes[i].Type.Name;
    }

    public override DateTime GetDateTime(int i)
    {
      return GetValue(i);
    }

    public override decimal GetDecimal(int i)
    {
      return GetValue(i);
    }

    public override double GetDouble(int i)
    {
      return GetValue(i);
    }

    public override Type GetFieldType(int i)
    {
      Type t = attributes[i].Type;
      if (!options.ExposeNullableTypes && IsNullable(t))
      {
        return StripNullableType(t);
      }
      return t;
    }

    public override float GetFloat(int i)
    {
      return GetValue(i);
    }

    public override Guid GetGuid(int i)
    {
      return GetValue(i);
    }

    public override short GetInt16(int i)
    {
      return GetValue(i);
    }

    public override int GetInt32(int i)
    {
      return GetValue(i);
    }

    public override long GetInt64(int i)
    {
      return GetValue(i);
    }

    public override string GetName(int i)
    {
      Attribute a = attributes[i];
      if (a.IsRelatedAttribute && options.PrefixRelatedObjectColumns)
      {
        return a.FullName;
      }
      return a.Name;
    }

    public override int GetOrdinal(string name)
    {
      for (int i = 0; i < attributes.Count; i++)
      {
        var a = attributes[i];

         if (!a.IsRelatedAttribute && a.Name == name)
         {
           return i;
         }

         if (options.PrefixRelatedObjectColumns && a.IsRelatedAttribute && a.FullName == name )
         {
          return i;
         }

         if (!options.PrefixRelatedObjectColumns && a.IsRelatedAttribute && a.Name == name)
         {
           return i;
         }


      }
      return -1;
    }

    public override string GetString(int i)
    {
      return GetValue(i);
    }



    public override int GetValues(object[] values)
    {
      for (int i = 0; i < attributes.Count; i++)
      {
        values[i] = GetValue(i);
      }
      return attributes.Count;
    }



    public override object GetValue(int i)
    {
      object o = GetValue(i);
      if (!options.ExposeNullableTypes && o == null)
      {
        return DBNull.Value;
      }
      return o;
    }

    public override bool IsDBNull(int i)
    {
      object o = GetValue(i);
      return (o == null);
    }

    public override object this[string name]
    {
      get { return GetValue(GetOrdinal(name)); }
    }

    public override object this[int i]
    {
      get { return GetValue(i); }
    }

    //

    //DbDataReader Members



    public override System.Collections.IEnumerator GetEnumerator()
    {
      return this.enumerator;
    }

    public override bool HasRows
    {
      get { throw new NotSupportedException(); }
    }
    //

  }

  public class EntityDataReaderOptions
  {
    public static EntityDataReaderOptions Default
    {
      get { return new EntityDataReaderOptions(true, false, true, false); }
    }

    public EntityDataReaderOptions(
      bool exposeNullableTypes,
      bool flattenRelatedObjects,
      bool prefixRelatedObjectColumns,
      bool recreateForeignKeysForEntityFrameworkEntities)
    {
      this.ExposeNullableTypes = exposeNullableTypes;
      this.FlattenRelatedObjects = flattenRelatedObjects;
      this.PrefixRelatedObjectColumns = prefixRelatedObjectColumns;
      this.RecreateForeignKeysForEntityFrameworkEntities = recreateForeignKeysForEntityFrameworkEntities;
    }








    public bool ExposeNullableTypes { get {return _ExposeNullableTypes; } set{ _ExposeNullableTypes=value; } } bool _ExposeNullableTypes;















    public bool FlattenRelatedObjects { get {return _FlattenRelatedObjects; } set{ _FlattenRelatedObjects=value; } } bool _FlattenRelatedObjects;









    public bool PrefixRelatedObjectColumns { get {return _PrefixRelatedObjectColumns; } set{ _PrefixRelatedObjectColumns=value; } } bool _PrefixRelatedObjectColumns;





    public bool RecreateForeignKeysForEntityFrameworkEntities { get {return _RecreateForeignKeysForEntityFrameworkEntities; } set{ _RecreateForeignKeysForEntityFrameworkEntities=value; } } bool _RecreateForeignKeysForEntityFrameworkEntities;

  }

  public        class EntityDataReaderExtensions
  {








    public static IDataReader AsDataReader(     IEnumerable collection)
    {




      if (typeof(T).IsDefined(typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute), false))
      {
        var options = EntityDataReaderOptions.Default;
        options.FlattenRelatedObjects = true;
        options.PrefixRelatedObjectColumns = false;
        return new EntityDataReader(collection,options);
      }
      return new EntityDataReader(collection);
    }








    public static IDataReader AsDataReader(     IEnumerable collection, bool exposeNullableColumns, bool flattenRelatedObjects)
    {
      EntityDataReaderOptions options = new EntityDataReaderOptions(exposeNullableColumns, flattenRelatedObjects, true, false);

      return new EntityDataReader(collection,options,null);
    }








    public static DataTable ToDataTable(     IEnumerable collection)
    {
      DataTable t = new DataTable();
      t.Locale = System.Globalization.CultureInfo.CurrentCulture;
      t.TableName = typeof(T).Name;
      EntityDataReaderOptions options = EntityDataReaderOptions.Default;
      options.ExposeNullableTypes = false;
      EntityDataReader dr = new EntityDataReader(collection, options);
      t.Load(dr);
      return t;
    }








    public static IDataReader AsDataReader(     IEnumerable collection, ObjectContext context) 
{
      EntityDataReaderOptions options = EntityDataReaderOptions.Default;
      options.RecreateForeignKeysForEntityFrameworkEntities = true;
      return new EntityDataReader(collection,options,context);
    }












    public static IDataReader AsDataReader(     IEnumerable collection, ObjectContext context, bool detachObjects, bool prefixRelatedObjectColumns) 
{
      EntityDataReaderOptions options = EntityDataReaderOptions.Default;
      options.RecreateForeignKeysForEntityFrameworkEntities = true;
      options.PrefixRelatedObjectColumns = prefixRelatedObjectColumns;

      if (detachObjects)
      {
        return new EntityDataReader(collection.DetachAllFrom(context),options,context);
      }
      return new EntityDataReader(collection,options,context);
    }
    static IEnumerable DetachAllFrom(     IEnumerable col, ObjectContext cx)
    {
      foreach (var t in col)
      {
        cx.Detach(t);
              return t;
      }
    }








    public static DataTable ToDataTable(     IEnumerable collection, ObjectContext context) 
{
      DataTable t = new DataTable();
      t.Locale = System.Globalization.CultureInfo.CurrentCulture;
      t.TableName = typeof(T).Name;

      EntityDataReaderOptions options = EntityDataReaderOptions.Default;
      options.RecreateForeignKeysForEntityFrameworkEntities = true;

      EntityDataReader dr = new EntityDataReader(collection, options, context);
      t.Load(dr);
      return t;
    }




  }
}

 