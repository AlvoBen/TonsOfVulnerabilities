using System;
using System.Collections.Generic;
using System.Data;
using System.Text;
using System.Text.RegularExpressions;
using com.calitha.goldparser;
using Epi;
using Epi.Collections;
using Epi.Data;
using Epi.Data.Services;
using Epi.Fields;
using VariableCollection = Epi.Collections.NamedObjectCollection;
using Epi.Core.AnalysisInterpreter.Rules;

namespace Epi.Core.AnalysisInterpreter
{
    public abstract class AnalysisRule
    {
        protected List NumericTypeList = new List( CxNull);
        protected Rule_Context Context;

        public AnalysisRule()
        {
            Context = new Rule_Context();
        }

        public AnalysisRule(Rule_Context context)
        {
            Context = context;
        }

        public AnalysisRule(IMemoryRegion currentModule)
        {
            Context = new Rule_Context(currentModule);
        }

        public abstract object Execute();

        protected string BoolVal(bool isTrue)
        {
            if (isTrue)
            {
                return "true";
            }
            else
            {
                return "false";
            }
        }

        protected bool IsNumeric(string value)
        {
            System.Text.RegularExpressions.Regex regex = new System.Text.RegularExpressions.Regex(@"^[-+]?\d+\.?\d*$|^[-+]?\d*\.?\d+$");
            return regex.IsMatch(value);
        }






        protected DataType GetDataType(string typeName)
        {
            DataType type = DataType.Unknown;

            try
            {
                foreach (Epi.DataSets.AppDataSet.DataTypesRow row in AppData.Instance.DataTypesDataTable.Rows)
                {
                    string expression = row.Expression;

                    if (!string.IsNullOrEmpty(expression) && (string.Compare(typeName, expression, true) == 0))
                    {
                        return (type = ((DataType)row.DataTypeId));
                    }
                }
            }
            catch
            {
            }

            return type;
        }







        protected string GetCommandElement(Token[] tokens, int index)
        {
            if (tokens[0] is NonterminalToken)
            {
                if (((NonterminalToken)tokens[0]).Tokens[index] is NonterminalToken)
                {
                    return ExtractTokens(((NonterminalToken)((NonterminalToken)tokens[0]).Tokens[index]).Tokens).Trim();
                }
                else
                {
                    return (((NonterminalToken)tokens[0]).Tokens[index]).ToString();
                }
            }
            else
            {
                if (tokens[index] is NonterminalToken)
                {
                    return ExtractTokens(((NonterminalToken)tokens[index]).Tokens).Trim();
                }
                else
                {
                    return (tokens[index]).ToString();
                }
            }
        }






        protected string ExtractTokens(Token[] tokens)
        {
            int max = tokens.GetUpperBound(0);
            string tokensInTree = "";

            for (int i = tokens.GetLowerBound(0); i <= max; i++)
            {
                if (tokens[i] is NonterminalToken)
                {
                    tokensInTree += ExtractTokens(((NonterminalToken)tokens[i]).Tokens);
                }
                else
                {
                    tokensInTree += tokens[i].ToString() + " ";
                }
            }

            return tokensInTree;
        }


        private static bool FoundName(string[] varNames, string name)
        {
            foreach (string variableName in varNames)
            {
                if (string.Compare(variableName, name, true) == 0)
                {
                    return true;
                }
            }

            return false;
        }





        public string CreateNegateRecode(Token token)
        {
            NonterminalToken nonterminal = (NonterminalToken)((NonterminalToken)token).Tokens[0];
            Rule_NegateExp result = new Rule_NegateExp(Context, nonterminal);
            return result.Execute().ToString();
        }

        static public AnalysisRule BuildStatments(Rule_Context context, Token token)
        {
            AnalysisRule result = null;
            if (token is NonterminalToken)
            {
                NonterminalToken nonterminal = (NonterminalToken)token;
                switch (nonterminal.Symbol.ToString())
                {
                    case "":
                        result = new Rule_Statements(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Statement(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Always(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Assign(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Assign_DLL_Statement(context, nonterminal);
                        break;
                    case "":
                    case "":
                        result = new Rule_If_Then_Else_End(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Define(context, nonterminal);
                        break;
                    case "":
                    case "":
                        result = new Rule_FunctionCall(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Dialog(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Read(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Merge(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Write(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Select(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Recode(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_CommentLine(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Execute(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Report(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_List(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Tables(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Freq(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Sort(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Means(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Relate(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Beep(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Quit(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Delete_Table_Long(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Delete_File(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Delete_Table(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Typeout(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_RouteOut(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_CloseOut(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Display(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                        result = new Rule_Header(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Undefine(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Run_File_PGM_Statement(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Run_String_Statement(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Run_PGM_In_Db_Statement(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Delete_Records_All_Statement(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Delete_Records_Selected_Statement(context, nonterminal);
                        break;
                    case "":
                    case "":
                        result = new Rule_Printout(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_SQLExec(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_RecordSet(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Define_Connection(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_LinearRegression(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_LogisticRegression(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_CoxPH(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_KMSurvival(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_DLL_Statement(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Define_Group(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Summarize(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Set(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Match(context, nonterminal);
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                        result = new Rule_Graph(context, nonterminal);
                        break;
                    case "<Expr List>":
                        result = new Rule_ExprList(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Expression(context, nonterminal);
                        break;
                    case "<And Exp>":
                        result = new Rule_AndExp(context, nonterminal);
                        break;
                    case "<Not Exp>":
                        result = new Rule_NotExp(context, nonterminal);
                        break;
                    case "<Compare Exp>":
                        result = new Rule_CompareExp(context, nonterminal);
                        break;
                    case "<Concat Exp>":
                        result = new Rule_ConcatExp(context, nonterminal);
                        break;
                    case "<Add Exp>":
                        result = new Rule_AddExp(context, nonterminal);
                        break;
                    case "<Mult Exp>":
                        result = new Rule_MultExp(context, nonterminal);
                        break;
                    case "<Pow Exp>":
                        result = new Rule_PowExp(context, nonterminal);
                        break;
                    case "<Negate Exp>":
                        result = new Rule_NegateExp(context, nonterminal);
                        break;
                    default:
                    case "":
                        result = new Rule_Value(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_UnDelete(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_QualifiedIdList(context, nonterminal);
                        break;
                    case "":
                        result = new Rule_Subroutine_Statement(context, nonterminal);
                        break;

                    //**these are not yet implemented; move up when completed
                    //**these are not yet implemented; move up when completed
                    //**these are not yet implemented; move up when completed
                    //**these are not yet implemented; move up when completed
                    //**these are not yet implemented; move up when completed

                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                    case "":
                        break;
                }
            }
            else 
            {
                TerminalToken terminal = (TerminalToken)token;

                switch (terminal.Symbol.ToString())
                {
                    case "":
                    default:
                        result = new Rule_Value(context, terminal);
                        break;
                }
            }

            return result;
        }

        static public List GetFunctionParameters(Rule_Context context, Token token)
        {
            List result = new List();

            if (token is NonterminalToken)
            {
                NonterminalToken nonterminal = (NonterminalToken)token;

                switch (nonterminal.Symbol.ToString())
                {
                    case "":
                        result.AddRange(AnalysisRule.GetFunctionParameters(context, nonterminal));
                        break;
                    case "":
                        result.AddRange(AnalysisRule.GetFunctionParameters(context, nonterminal));
                        break;
                    case "":
                        break;
                    case "":
                        result.AddRange(AnalysisRule.GetFunctionParameters(context, nonterminal.Tokens[0]));
                        result.Add(AnalysisRule.BuildStatments(context, nonterminal.Tokens[2]));
                        break;
                    case "":
                    case "":
                    case "":
                    case "":
                    default:
                        result.Add(AnalysisRule.BuildStatments(context, nonterminal));
                        break;
                }
            }
            else
            {
                TerminalToken terminal = (TerminalToken)token;
                if (terminal.Text != ",")
                {
                    result.Add(new Rule_Value(context, token));
                }
            }

            return result;
        }






        static public string[] SpliIdentifierList(string value)
        {
            List result = new List();
            StringBuilder temp = new StringBuilder();

            int Level = 0;

            foreach (char c in value)
            {
                if (c == ' ' && Level == 0)
                {
                    result.Add(temp.ToString().ToUpper());
                    temp.Length = 0;
                }
                else
                {
                    if (c == '[')
                    {
                        Level++;
                    }
                    else if (c == ']')
                    {
                        Level--;
                    }
                    else
                    {
                        temp.Append(c);
                    }
                }
            }
            result.Add(temp.ToString().ToUpper());
            return result.ToArray();
        }

        public string SetQualifiedId(Token token)
        {
            string result = null;

            if (token is NonterminalToken)
            {
                NonterminalToken nonterminal = (NonterminalToken)token;
                switch (nonterminal.Symbol.ToString())
                {
                    case "":
                        result = this.SetFully_Qualified_Id(nonterminal);
                        break;
                    default:
                        result = this.GetCommandElement(nonterminal.Tokens, 0).Trim( CxNull);
                        break;
                }
            }
            else
            {
                TerminalToken terminal = (TerminalToken)token;
                result = terminal.Text.Trim( CxNull);
            }

            return result;
        }


        public string SetFully_Qualified_Id(NonterminalToken pToken)
        {
            string result = null;
            result = this.GetCommandElement(pToken.Tokens, 0).Trim( CxNull) + "." + this.SetQualifiedId(pToken.Tokens[2]);
            return result;
        }

        protected object ConvertStringToBoolean(string pValue)
        {
            object result = null;
            switch (pValue.ToUpper())
            {
                case "(+)":
                case "YES":
                case "Y":
                case "TRUE":
                case "T":
                    result = true;
                    break;

                case "(-)":
                case "NO":
                case "N":
                case "FALSE":
                case "F":
                    result = false;
                    break;
            }
            return result;
        }
    }
}

 