using System;
using System.Collections.Generic;
using System.Text;
using com.calitha.goldparser;

namespace Epi.Core.AnalysisInterpreter.Rules
{



    public class Rule_Sort : AnalysisRule
    {
        List SortList = null;
        List SortOption = null;
        bool CancelSort = false;
        bool HasRun = false;

        public Rule_Sort(Rule_Context pContext, NonterminalToken pToken) : base(pContext)
        {


            /*
            !***         SortStatement     ***!
                   ::= SORT 
                                            | SORT |CANCEL SORT

                    ::=   ASCENDING
                                            | DESCENDING
                                            | !Null

                     ::= Identifier 

                    ::=  
                                            |
                 ::= SORT
                  ::= CANCEL SORT
            !***   End        ***!

            */

            this.SortList = new List();
            this.SortOption = new List();

            if (pToken.Tokens.Length == 1)
            {
                this.CancelSort = true;
            }
            else
            {
                if (pToken.Tokens[0].ToString().ToUpper() == "CANCEL")
                {
                    this.CancelSort = true;
                }
                else
                {
                    this.SetSortList((NonterminalToken)pToken.Tokens[1]);
                }
            }

        }




        private void SetSortList(NonterminalToken pToken)
        {


            switch (pToken.Symbol.ToString())
            {
                case "":
                    this.SetSortList((NonterminalToken) pToken.Tokens[0]);
                    this.SetSort((NonterminalToken) pToken.Tokens[1]);
                    break;
                case "":
                    this.SetSort(pToken);
                    break;
            }

        }


        private void SetSort(NonterminalToken pToken)
        {
            /*
             ::= Identifier 
             ::= ASCENDING | DESCENDING | !Null
            */
            if (pToken.Tokens.Length > 1)
            {
                this.SortList.Add(this.GetCommandElement(pToken.Tokens,0).Trim( CxNull));
                switch(this.GetCommandElement(pToken.Tokens, 1).ToUpper())
                {
                    case "DESCENDING":
                    case "DESC":
                        this.SortOption.Add("DESC");
                        break;
                    default:
                        this.SortOption.Add("ASC");
                        break;
                }
            }
            else
            {
                this.SortList.Add(this.GetCommandElement(pToken.Tokens, 0).Trim( CxNull));
                this.SortOption.Add("ASC");
            }
        }





        public override object Execute()
        {
            object result = null;

            if (!this.HasRun)
            {
                this.Context.NewSortNeeded = true;

                this.Context.SortExpression.Length = 0;

                if (!this.CancelSort)
                {
                    this.Context.SortExpression.Length = 0;

                    for (int i = 0; i < this.SortList.Count; i++)
                    {
                        if (this.Context.SortExpression.Length == 0)
                        {
                            this.Context.SortExpression.Append("[");
                            this.Context.SortExpression.Append(this.SortList[i]);
                            this.Context.SortExpression.Append("] ");
                            this.Context.SortExpression.Append(this.SortOption[i]);
                        }
                        else
                        {
                            this.Context.SortExpression.Append(", [");
                            this.Context.SortExpression.Append(this.SortList[i]);
                            this.Context.SortExpression.Append("] ");
                            this.Context.SortExpression.Append(this.SortOption[i]);
                        }
                    }
                }
                else
                {

                    this.Context.SortExpression.Length = 0;
                }

                this.Context.GetOutput(); 

                Dictionary args = new Dictionary();
                args.Add("COMMANDNAME", CommandNames.SORT);
                this.Context.AnalysisCheckCodeInterface.Display(args);

                this.HasRun = true;
            }

            return result;
        }

    }




    public class Rule_SortItem : AnalysisRule
    {
        //Constructors







        public Rule_SortItem(NonterminalToken pToken, List pList, List pOption)
        {


            switch(pToken.Rule.Lhs.ToString())
            {
                case "":
                    pList.Add(this.GetCommandElement(pToken.Tokens, 0));
                    if (pToken.Tokens.Length > 1)
                    {
                        string Test = this.GetCommandElement(pToken.Tokens, 1);
                        switch (Test.ToUpper())
                        {
                            case "DESCENDING":
                                pOption.Add("DESC");
                                break;
                            default:
                                pOption.Add("ASC");
                                break;
                        }
                    }
                    else
                    {
                        pOption.Add("ASC");
                    }
                    break;
                case "":
                    new Rule_SortItem((NonterminalToken) pToken.Tokens[0], pList, pOption);
                    if (pToken.Tokens.Length > 1)
                    {
                        new Rule_SortItem((NonterminalToken)pToken.Tokens[1], pList, pOption);
                    }
                    break;
            }

        }

        //

        //Public Methods





        public override object Execute()
        {
            return null;
        }

        //
    }
}


 