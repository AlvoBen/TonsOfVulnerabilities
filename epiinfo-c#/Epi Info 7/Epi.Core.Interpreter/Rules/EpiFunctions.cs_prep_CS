using System;
using System.Collections.Generic;
using System.Text;

using com.calitha.goldparser;

using Epi.Core.AnalysisInterpreter;

namespace Epi.Core.AnalysisInterpreter.Rules
{
    /*
 ::= ABS
  |COS
  |DAY|DAYS
  |ENVIRON|EXISTS|EXP
  |FILEDATE|FINDTEXT|FORMAT
  |HOUR|HOURS
  |LN|LOG
  |MINUTES|Month|MONTHS
  |NUMTODATE|NUMTOTIME
  |RECORDCOUNT|RND|ROUND
  |SECOND|SECONDS|STEP|SUBSTRING|SIN
  |TRUNC|TXTTODATE|TXTTONUM|TAN
  |UPPERCASE
  |YEAR|YEARS

 ::= SYSTEMTIME|SYSTEMDATE

 ::=  '('  ')'
   |  '('  ')'
   | 
 ::=  | 
 ::=  | 
 ::=  ',' 
 ::= 
 ::=
     */




    public         class Rule_FunctionCall : AnalysisRule
    {
        private string functionName = null;
        private AnalysisRule functionCall = null;

        private string ClassName = null;
        private string MethodName = null;
        private List ParameterList = new List();

        //Constructors





        public Rule_FunctionCall(Rule_Context pContext, NonterminalToken pToken) : base(pContext)
        {
            /*
             ::=  '('  ')'
       |  '('  ')'
       | 
             */

            NonterminalToken T;
            if (pToken.Tokens.Length == 1)
            {
                if (pToken.Rule.ToString().Equals(""))
                {
                    T = (NonterminalToken)pToken.Tokens[0];
                }
                else
                {
                    T = pToken;
                }
            }
            else
            {
                T = (NonterminalToken)pToken.Tokens[2];
            }


            string temp = null;
            string[] temp2 = null;

            if (pToken.Tokens[0] is NonterminalToken)
            {
                temp = this.ExtractTokens(((NonterminalToken)pToken.Tokens[0]).Tokens).Replace(" . ", ".");
                temp2 = temp.Split('.');

            }
            else
            {
                temp = ((TerminalToken)pToken.Tokens[0]).Text.Replace(" . ", ".");
            }

            if(temp2 != null && temp2.Length > 1)
            {
                this.ClassName = temp2[0].Trim();
                this.MethodName = temp2[1].Trim();

                this.ParameterList = AnalysisRule.GetFunctionParameters(pContext, (NonterminalToken)pToken.Tokens[2]);
            }
            else
            {
                functionName = this.GetCommandElement(pToken.Tokens, 0).ToString();

                switch (functionName.ToUpper())
                {
                    case "ABS":
                        functionCall = new Rule_Abs(pContext, T);
                        break;
                    case "COS":
                        functionCall = new Rule_Cos(pContext, T);
                        break;
                    case "DAY":
                        functionCall = new Rule_Day(pContext, T);
                        break;
                    case "DAYS":
                        functionCall = new Rule_Days(pContext, T);
                        break;
                    case "FORMAT":
                        functionCall = new Rule_Format(pContext, T);
                        break;
                    case "HOUR":
                        functionCall = new Rule_Hour(pContext, T);
                        break;
                    case "HOURS":
                        functionCall = new Rule_Hours(pContext, T);
                        break;
                    case "MINUTE":
                        functionCall = new Rule_Minute(pContext, T);
                        break;
                    case "MINUTES":
                        functionCall = new Rule_Minutes(pContext, T);
                        break;
                    case "MONTH":
                        functionCall = new Rule_Month(pContext, T);
                        break;
                    case "MONTHS":
                        functionCall = new Rule_Months(pContext, T);
                        break;
                    case "NUMTODATE":
                        functionCall = new Rule_NumToDate(pContext, T);
                        break;
                    case "NUMTOTIME":
                        functionCall = new Rule_NumToTime(pContext, T);
                        break;
                    case "RECORDCOUNT":
                        functionCall = new Rule_RecordCount(pContext, T);
                        break;
                    case "SECOND":
                        functionCall = new Rule_Second(pContext, T);
                        break;
                    case "SECONDS":
                        functionCall = new Rule_Seconds(pContext, T);
                        break;
                    case "SYSTEMDATE":
                        functionCall = new Rule_SystemDate(pContext, T);
                        break;
                    case "SYSTEMTIME":
                        functionCall = new Rule_SystemTime(pContext, T);
                        break;
                    case "TXTTODATE":
                        functionCall = new Rule_TxtToDate(pContext, T);
                        break;
                    case "TXTTONUM":
                        functionCall = new Rule_TxtToNum(pContext, T);
                        break;
                    case "YEAR":
                        functionCall = new Rule_Year(pContext, T);
                        break;
                    case "YEARS":
                        functionCall = new Rule_Years(pContext, T);
                        break;
                    case "STRLEN":
                        functionCall = new Rule_STRLEN(pContext, T);
                        break;
                    case "SUBSTRING":
                        functionCall = new Rule_Substring(pContext, T);
                        break;
                    case "RND":
                        functionCall = new Rule_Rnd(pContext, T);
                        break;
                    case "EXP":
                        functionCall = new Rule_Exp_Func(pContext, T);
                        break;
                    case "LN":
                        functionCall = new Rule_LN_Func(pContext, T);
                        break;
                    case "ROUND":
                        functionCall = new Rule_Round(pContext, T);
                        break;
                    case "LOG":
                        functionCall = new Rule_LOG_Func(pContext, T);
                        break;
                    case "SIN":
                        functionCall = new Rule_Sin(pContext, T);
                        break;
                    case "TAN":
                        functionCall = new Rule_Tan(pContext, T);
                        break;
                    case "TRUNC":
                        functionCall = new Rule_TRUNC(pContext, T);
                        break;
                    case "STEP":
                        functionCall = new Rule_Step(pContext, T);
                        break;
                    case "UPPERCASE":
                        functionCall = new Rule_UpperCase(pContext, T);
                        break;
                    case "FINDTEXT":
                        functionCall = new Rule_FindText(pContext, T);
                        break;
                    case "ENVIRON":
                        functionCall = new Rule_Environ(pContext, T);
                        break;
                    case "EXISTS":
                        functionCall = new Rule_Exists(pContext, T);
                        break;
                    case "FILEDATE":
                        functionCall = new Rule_FileDate(pContext, T);
                        break;
                    case "ZSCORE":
                        functionCall = new Rule_ZSCORE(pContext, T);
                        break;
                    case "PFROMZ":
                        functionCall = new Rule_PFROMZ(pContext, T);
                        break;
                    case "EPIWEEK":
                        functionCall = new Rule_EPIWEEK(pContext, T);
                        break;
                    default:
                            throw new Exception("Function name " + functionName.ToUpper() + " is not a recognized function.");

                }
            }

        }



        //

        //Public Methods




        public override object Execute()
        {
            object result = null;
            if (string.IsNullOrEmpty(this.functionName))
            {

                if (this.Context.DLLClassList.ContainsKey(this.ClassName.ToLower()))
                {
                    object[] args = this.ParameterList.ToArray();
                    if (this.ParameterList.Count > 0)
                    {
                        args = new object[this.ParameterList.Count];
                        for (int i = 0; i < this.ParameterList.Count; i++)
                        {
                            args[i] = this.ParameterList[i].Execute();
                        }
                    }
                    else
                    {
                        args = new object[0];
                    }

                    result = this.Context.DLLClassList[this.ClassName].Execute(this.MethodName, args);
                }
            }
            else
            {
                if (this.functionCall != null)
                {
                    result = this.functionCall.Execute();
                }
            }
            return result;
        }



        //
    }




    public         class Rule_FunctionParameterList : AnalysisRule
    {
        public Stack paramList = null;

        //Constructors





        public Rule_FunctionParameterList(Rule_Context pContext, NonterminalToken pToken) : base(pContext)
        {



            NonterminalToken T = (NonterminalToken)pToken.Tokens[0];

            switch (T.Rule.Lhs.ToString())
            {
                case "":
                    this.paramList = new Stack();


                    new Rule_NonEmptyFunctionParameterList(pContext, T, this.paramList);
                    break;
                case "":
                    this.paramList = new Stack();
                    new Rule_SingleFunctionParameterList(pContext, T, this.paramList);
                    break;
                case "":


                    break;
                case "":
                    this.paramList = new Stack();

                    new Rule_MultipleFunctionParameterList(pContext, T, this.paramList);
                    break;
            }
        }

        //

        //Public Methods





        public override object Execute()
        {
            object result = null;
            return result;
        }

        //


    }




    public         class Rule_EmptyFunctionParameterList : AnalysisRule
    {
        //Constructors
        public Rule_EmptyFunctionParameterList(Rule_Context pContext, NonterminalToken pToken) : base(pContext)
        {

        }
        //
        //Public Methods




        public override object Execute()
        {
            return String.Empty;
        }
        //
    }




    public         class Rule_NonEmptyFunctionParameterList : AnalysisRule
    {
        protected Stack MultipleParameterList = null;


        //Constructors
        public Rule_NonEmptyFunctionParameterList(Rule_Context pContext, NonterminalToken pToken) : base(pContext)
        {


            NonterminalToken T = (NonterminalToken) pToken.Tokens[0];

            switch (T.Rule.Lhs.ToString())
            {
                case "":
                    this.MultipleParameterList = new Stack();

                    new Rule_MultipleFunctionParameterList(pContext, T, this.MultipleParameterList);
                    break;
                case "":

                    new Rule_SingleFunctionParameterList(pContext, T, this.MultipleParameterList);
                    break;
            }
        }

        public Rule_NonEmptyFunctionParameterList(Rule_Context pContext, NonterminalToken pToken, Stack pList) : base(pContext)
        {


            NonterminalToken T = (NonterminalToken) pToken.Tokens[0];

            switch (T.Rule.Lhs.ToString())
            {
                case "":
                    new Rule_MultipleFunctionParameterList(pContext, T, pList);

                    break;
                case "":
                    new Rule_SingleFunctionParameterList(pContext, T, pList);
                    break;
                default:

                    break;
            }

            if (pToken.Tokens.Length > 2)
            {
                Rule_Expression Expression = new Rule_Expression(pContext, (NonterminalToken)pToken.Tokens[2]);
                pList.Push(Expression);
            }
        }
        //
        //Public Methods





        public override object Execute()
        {
            return null;
        }
        //
    }




    public         class Rule_MultipleFunctionParameterList : AnalysisRule
    {
        private AnalysisRule Expression = null;
        private AnalysisRule nonEmptyList = null;
        //Constructors
        public Rule_MultipleFunctionParameterList(Rule_Context pContext, NonterminalToken pToken, Stack pList) : base(pContext)
        {


            NonterminalToken nonEmptyToken = (NonterminalToken)pToken.Tokens[0];
            NonterminalToken ExpressionToken = (NonterminalToken)pToken.Tokens[2];



            pList.Push(AnalysisRule.BuildStatments(pContext, nonEmptyToken));
            pList.Push(AnalysisRule.BuildStatments(pContext, ExpressionToken));


        }
        //
        //Public Methods





        public override object Execute()
        {
            object result = null;





            return result;
        }
        //
    }




    public         class Rule_SingleFunctionParameterList : AnalysisRule
    {
        private AnalysisRule Expression = null;

        //Constructors
        public Rule_SingleFunctionParameterList(Rule_Context pContext, NonterminalToken pToken, Stack pList) : base(pContext)
        {

            this.Expression = new Rule_Expression(pContext, (NonterminalToken)pToken.Tokens[0]);
            pList.Push(this.Expression);
        }
        //
        //Public Methods





        public override object Execute()
        {
            object result = null;
            result = this.Expression.Execute();
            return result;
        }
        //
    }













    //****
    //**** Not implemented yet, but on the list of features
    //****
























































    public        class FunctionUtils
    {
        public enum DateInterval
        {
            Second,
            Minute,
            Hour,
            Day,
            Month,
            Year
        }







        public static object GetDatePart(DateInterval interval, DateTime date)
        {
            object returnValue = null;
            switch (interval)
            {
                case DateInterval.Second:
                    returnValue = date.Second;
                    break;
                case DateInterval.Minute:
                    returnValue = date.Minute;
                    break;
                case DateInterval.Hour:
                    returnValue = date.Hour;
                    break;
                case DateInterval.Day:
                    returnValue = date.Day;
                    break;
                case DateInterval.Month:
                    returnValue = date.Month;
                    break;
                case DateInterval.Year:
                    returnValue = date.Year;
                    break;
            }

            return returnValue;
        }








        public static object GetDateDiff(DateInterval interval, DateTime date1, DateTime date2)
        {
            object returnValue = null;
            TimeSpan t;

            object diff = 0.0;


            t = date2 - date1;

            switch (interval)
            {
                case DateInterval.Second:
                    diff = t.TotalSeconds;
                    break;
                case DateInterval.Minute:
                    diff = t.TotalMinutes;
                    break;
                case DateInterval.Hour:
                    diff = t.TotalHours;
                    break;
                case DateInterval.Day:
                    diff = t.TotalDays;
                    break;
                case DateInterval.Month:
                    diff = t.TotalDays / 365.25 * 12.0;
                    break;
                case DateInterval.Year:
                    diff = t.TotalDays / 365.25;
                    break;
            }

            returnValue = Convert.ToInt32(diff);
            return returnValue;
        }






        public static string StripQuotes(string s)
        {
            return s.Trim( CxNull





 