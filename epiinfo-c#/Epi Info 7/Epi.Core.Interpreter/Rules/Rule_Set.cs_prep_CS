using System;
using System.Collections.Generic;
using System.Text;
using com.calitha.goldparser;

namespace Epi.Core.AnalysisInterpreter.Rules
{
    public class Rule_Set : AnalysisRule
    {
        /*
        !***     Set  Statement    ***!
         ::= SET  End-Set

         ::=  STATISTICS '='  !These options could be set in FREQ,MATCH, and MEANS commands also
            | PROCESS '=' 
            | PROCESS '=' Identifier
            | Boolean '=' String
            | YN '=' String ',' String ',' String
            | DELETED '=' 
            | PERCENTS '=' 
            | MISSING '=' 
            | IGNORE '=' 
            | SELECT '=' 
            | FREQGRAPH '=' 
            | HYPERLINKS '=' 
            | SHOWPROMPTS '=' 
            | TABLES '=' 
            | USEBROWSER '=' 

         ::=  
            | 

         ::= ON
            | OFF
            | Boolean

         ::= 
            |Identifier

         ::= NONE
            | MINIMAL
            | INTERMEDIATE
            | COMPLETE

         ::= UNDELETED
            | DELETED
            | BOTH

        !***    End      ***!
        */

        Dictionary _setOptions = new Dictionary(StringComparer.OrdinalIgnoreCase);

        public Rule_Set(Rule_Context pContext, NonterminalToken pToken) : base(pContext)
        {
            foreach (Token T in pToken.Tokens)
            {
                if (T is NonterminalToken)
                {
                    NonterminalToken NT = (NonterminalToken)T;
                    switch (NT.Symbol.ToString())
                    {
                        case "":
                            this.SetSetList(NT);
                            break;
                        case "":
                            this.SetSetClause(NT);
                            break;
                    }
                }
            }
        }

        private void SetSetList(NonterminalToken nonTermToken)
        {


            foreach (Token token in nonTermToken.Tokens)
            {
                if (token is NonterminalToken)
                {
                    NonterminalToken asNonTermToken = (NonterminalToken)token;

                    switch (asNonTermToken.Symbol.ToString())
                    {
                        case "":
                            this.SetSetClause(asNonTermToken);
                            break;

                        case "":
                            foreach (NonterminalToken tokenInList in asNonTermToken.Tokens)
                            {
                                this.SetSetClause(tokenInList);
                            }
                            break;
                    }
                }
            }
        }

        private void SetSetClause(NonterminalToken nonTermToken)
        {
















            string Key = this.GetCommandElement(nonTermToken.Tokens, 0);
            string Value = null;
            Token token = nonTermToken.Tokens[2];

            if (token is NonterminalToken)
            {
                Value = this.ExtractTokens(((NonterminalToken)token).Tokens).Trim();
            }
            else
            {
                Value = this.GetCommandElement(nonTermToken.Tokens, 2).Trim();
            }

            if (_setOptions.ContainsKey(Key))
            {
                _setOptions[Key] = Value.Trim('"');
            }
            else
            {
                _setOptions.Add(Key, Value.Trim('"'));
            }
        }





        public override object Execute()
        {
            this.Context.AddConfigSettings(_setOptions);
            return null;
        }
    }
}

 