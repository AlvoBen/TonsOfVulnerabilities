/*
 This file is generated by Code Generator
 for CIMClass SAP_ITSAMJ2eeLicensingManagementService
 */

package com.sap.engine.services.licensing.itsam;

import java.util.Iterator;
import java.util.Vector;

import javax.management.MBeanException;

import com.sap.engine.frame.core.licensing.LicenseKeyValue;
import com.sap.engine.services.licensing.LicensingException;
import com.sap.engine.services.licensing.LicensingRuntimeInterface;
import com.sap.engine.services.licensing.itsam.cd.SAP_ITSAMJ2eeHardwareEntry;
import com.sap.engine.services.licensing.itsam.cd.SAP_ITSAMJ2eeLicense;
import com.sap.tc.logging.Location;
import com.sap.tc.logging.Severity;

/*
 * ManagedElement is an abstract class that provides a common superclass (or top of the
 * inheritance tree) for the non-association classes in the CIM Schema.
 * 
 * @version
 */

public class SAP_ITSAMJ2eeLicensingManagementService_Impl 
implements SAP_ITSAMJ2eeLicensingManagementService {

  private static final Location LOC = 
    Location.getLocation(SAP_ITSAMJ2eeLicensingManagementService_Impl.class);
//  private static final Category CAT = Category.SYS_SERVER;
  
  private LicensingRuntimeInterface service;
  
  /**
   * @param service
   */
  public SAP_ITSAMJ2eeLicensingManagementService_Impl(LicensingRuntimeInterface service) {
    this.service = service;
  }

  public String getSystemId() {
    return service.getSystemId();
  }

  public String getSystemType() {
    return service.getSystemType();
  }

  public void setSystemType(String systemType) {
    service.setSystemType(systemType);
  }

  public String getSystemNumber() {
    return service.getSysNo();
  }

  public String[] getSystemTypes() {
    return new String[] {
      LicensingRuntimeInterface.DEVELOPMENT_SYSTEM,
      LicensingRuntimeInterface.TRAINING_SYSTEM,
      LicensingRuntimeInterface.TEST_SYSTEM,
      LicensingRuntimeInterface.PRODUCTIVE_SYSTEM
    };
  }

  public String getInstallationNumber() {
    return service.getInstNo();
  }

  public String getHardwareId() {
    return service.getHardwareId();
  }

  /*
   * 
   * @return SAP_ITSAMJ2eeLicense
   */
  public SAP_ITSAMJ2eeLicense[] getLicenses() {
    Vector licenses = service.getLicensingInformation();
    SAP_ITSAMJ2eeLicense[] res = new SAP_ITSAMJ2eeLicense[licenses.size()];
    for(int i = 0; i < licenses.size(); i++) {
      LicenseKeyValue nextLicense = (LicenseKeyValue) licenses.elementAt(i);
      
      SAP_ITSAMJ2eeHardwareEntry[] remoteHardwareEntries = 
        getRemoteHardwareEntries(nextLicense);
      
      res[i] = 
        new SAP_ITSAMJ2eeLicense(
          nextLicense.getValidity(),
          nextLicense.getSystemID(),
          nextLicense.getSystNo(), 
          nextLicense.getSwProduct(), 
          nextLicense.getHwKey(), 
          nextLicense.getBeginDate(), 
          nextLicense.getEndDate(), 
          nextLicense.getType(), 
          nextLicense.getSwProductLimit(), 
          nextLicense.getInstNo(), 
          remoteHardwareEntries, 
          nextLicense.isExtendable(),
          getCaption(),
          getDescription(),
          getElementName());
    }
    return res;
  }
  
  private SAP_ITSAMJ2eeHardwareEntry[] getRemoteHardwareEntries(
    LicenseKeyValue nextLicense) {
    
    SAP_ITSAMJ2eeHardwareEntry[] res = new SAP_ITSAMJ2eeHardwareEntry[0];
    //TODO
    return res;
  }


	public String getSapStorageVendorId()
	{
		return service.getSapStorageVendorId();
	}


  /*
   * The Caption property is a short textual description (one- line string) of the object.
   * @return String
   */

  public String getCaption() {
    return "Licensing Management Service";
  }

  /*
   * The Description property provides a textual description of the object. @return String
   */

  public String getDescription() {
    return 
      "Service, providing functionality for requesting, installing and prolonging " +
      "SAP software licenses, as well as just viewing what licenses are there " +
      "installed on the system.";
  }

  /*
   * A user-friendly name for the object. This property allows each instance to define a
   * user-friendly name IN ADDITION TO its key properties/identity data, and description
   * information. Note that ManagedSystemElement's Name property is also defined as a
   * user-friendly name. But, it is often subclassed to be a Key. It is not reasonable
   * that the same property can convey both identity and a user friendly name, without
   * inconsistencies. Where Name exists and is not a Key (such as for instances of
   * LogicalDevice), the same information MAY be present in both the Name and ElementName
   * properties. @return String
   */

  public String getElementName() {
    // TODO Generated Code. Implementation to be done here.
    // Leave it as it is
    return null;
  }

  public void installLicense(String fileName, byte[] fileContent) throws MBeanException {
    try {
      service.installLicense(fileName, fileContent);
    } catch(LicensingException e) {
      reportException(e);
    }
  }

  public void deleteLicense(String systemID, String hardwareID, String softwareProduct) throws MBeanException {
    try {
      service.deleteLicense(systemID, hardwareID, softwareProduct);
    } catch(LicensingException e) {
      reportException(e);
    }
  }

  public void extendLicense(String softwareProduct) throws MBeanException {
    try {
      service.installSubsequentTempLicense(softwareProduct);
    } catch(LicensingException e) {
      reportException(e);
    }
  }

  public boolean checkLicense(String softwareProduct) throws MBeanException {
	try 
	{
		return service.checkLicense(softwareProduct);
	} 
	catch(Exception e) 
	{
	   LOC.traceThrowableT(Severity.ERROR, e.getMessage(), e);
	   throw new MBeanException(e);
	}
  }
  
  private void reportException(LicensingException e) throws MBeanException {
    StringBuffer msg = new StringBuffer();
    for(Iterator iter = e.getErrorMessage().iterator(); iter.hasNext();) {
      String next = (String) iter.next();
      msg.append(next);
      if(iter.hasNext()) {
        msg.append(System.getProperty("line.separator"));
      }
      LOC.errorT(next);
    }
    LOC.traceThrowableT(Severity.ERROR, e.getMessage(), e);
    Exception ex = new Exception(msg.toString(), e);
    throw new MBeanException(ex, msg.toString());
  }
}