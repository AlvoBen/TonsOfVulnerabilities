/*
 * Copyright (c) 2005 by SAP AG, Walldorf.,
 * url: http://www.sap.com
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of SAP AG, Walldorf. You shall not disclose such Confidential
 * Information and shall use it only in accordance with the terms
 * of the license agreement you entered into with SAP.
 */

package com.sap.scheduler.api;

import java.io.Serializable;
import java.text.SimpleDateFormat;

/**
 * Instances of this class are used by the scheduler to filter out timeout events. I.e. job instances
 * generated by some scheduler task may not be executed during the time frame <code>startTime</code>
 * -<c>endTime</c>. It is the scheduler that decides which jobs may be filtered out by this filter.
 * For example the scheduler may use a given filter to suppress occurences only of a given scheduler task
 * or it may use the filter to suppress expirations of all timer tasks.Instances of this class are immutable.
 * It does not provide set methods and instances of <c>SchedulerTime</c>, aggregated by <c>Filter</c>
 * are also immutable.
 */
public final class Filter implements Serializable {
  private SchedulerTime startTime;
  private SchedulerTime endTime;

  /**
   * Creates new instance of <c>Filter</c> for the specified time period
   *
   * @param startTime - start time of the filter
   * @param endTime   - end time of the filter
   */
  public Filter(SchedulerTime startTime, SchedulerTime endTime) {
    if (startTime.compareTo(endTime) == 1) {
      throw new IllegalArgumentException("start time points to a moment in time later than endTime");
    }
    if (!startTime.getTimeZone().hasSameRules(endTime.getTimeZone())) {
      throw new IllegalArgumentException("start time has a different time zone than end time");
    }
    this.startTime = startTime;
    this.endTime = endTime;
  }

  /**
   * Obtains the start time of the filter
   *
   * @return the start time of the filter
   */
  public SchedulerTime getStartTime() {
    return startTime;
  }

  /**
   * Obtains the end time of the filter
   *
   * @return the end time of the filter
   */
  public SchedulerTime getEndTime() {
    return endTime;
  }

  /**
   * Checks if the given time is to be filtered out
   *
   * @param time the specified scheduler time
   * @return TRUE if the time is to be filtered out, FALSE if not
   */
  public boolean filterOut(SchedulerTime time) {
    return filterOut(time.timeMillis());
  }

  /**
   * Checks if the given time is to be filtered out
   *
   * @param time the specified time in milliseconds
   * @return TRUE if the time is to be filtered out, FALSE if not
   */
  public boolean filterOut(long time) {
    return time <= endTime.timeMillis() && time >= startTime.timeMillis();
  }

  /**
   * Returns a string representation of the filter
   *
   * @return the string representation
   */
  public String toString() {
    SimpleDateFormat sdf = new SimpleDateFormat();
    sdf.setTimeZone(startTime.getTimeZone());
    return "[" + startTime.timeMillis() + "-" + endTime.timeMillis() + "] <=> [" +
            sdf.format(startTime.getTime()) + "-" + sdf.format(endTime.getTime()) + "]";
  }
  
  
  /**
   * Compares a Filter with this.
   * 
   * @param entry the Filter to compare
   * @return true if the Filter are equals in case of StartTime, EndTime otherwise false.
   */
  public boolean compareFilter(Filter entry) {
      // equals is overwritten in SchedulerTime and compares the Time in millis in UTC
      if (this.getStartTime() != null) {
          if ( !this.getStartTime().equals(entry.getStartTime()) ) {
              return false;
          }
      }
      if (this.getEndTime() != null) {
          if ( !this.getEndTime().equals(entry.getEndTime()) ) {
              return false;
          }
      }
      return true;
  }
}
